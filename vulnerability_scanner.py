import requests
from urllib.parse import urlparse
import ssl
import socket
import subprocess
import threading
import json
import time

# Function to check SSL certificate validity, expiration date, and issuer
def check_ssl_cert(domain):
    try:
        context = ssl.create_default_context()
        with socket.create_connection((domain, 443)) as sock:
            with context.wrap_socket(sock, server_hostname=domain) as ssock:
                cert = ssock.getpeercert()
                cert_expiration = cert['notAfter']
                cert_issuer = dict(cert['issuer'])
                return {
                    "status": "Valid SSL Certificate",
                    "cert_subject": dict(cert['subject']),
                    "cert_issuer": cert_issuer,
                    "cert_expiration": cert_expiration
                }
    except ssl.SSLError as e:
        return {"status": "SSL Certificate Error", "error": str(e)}
    except Exception as e:
        return {"status": "Failed to connect for SSL check", "error": str(e)}

# Function to check for HTTP security headers
def check_security_headers(headers):
    security_headers = {
        "Content-Security-Policy": False,
        "X-Frame-Options": False,
        "X-Content-Type-Options": False,
        "Strict-Transport-Security": False,
        "Referrer-Policy": False,
        "Rate-Limiting": False  # Detect rate limiting
    }
    
    for header in security_headers.keys():
        if header in headers:
            security_headers[header] = True
    
    # Detect API rate limiting
    if "X-RateLimit-Limit" in headers:
        security_headers["Rate-Limiting"] = True

    return security_headers

# Function to check for open ports using nmap
def check_open_ports(domain):
    try:
        nmap_scan = subprocess.run(["nmap", "-p-", domain], capture_output=True, text=True)
        return nmap_scan.stdout
    except Exception as e:
        return f"Nmap Scan Error: {str(e)}"

# Function to check for SQL Injection or XSS vulnerabilities in response content
def content_inspection(response_text):
    vulnerabilities = {
        "SQL Injection": False,
        "XSS": False
    }
    
    sql_injection_signatures = ["sql syntax", "sql error", "mysql", "unexpected end of SQL"]
    xss_signatures = ["<script>", "alert(", "onerror", "javascript:"]
    
    # Check for SQL injection patterns
    if any(signature in response_text.lower() for signature in sql_injection_signatures):
        vulnerabilities["SQL Injection"] = True

    # Check for XSS patterns
    if any(signature in response_text.lower() for signature in xss_signatures):
        vulnerabilities["XSS"] = True
    
    return vulnerabilities

# Function to scan vulnerabilities
def scan_vulnerabilities(endpoint):
    result = {"url": endpoint}
    
    # Check if the endpoint is accessible
    try:
        start_time = time.time()  # Start timer for response time measurement
        response = requests.get(endpoint)
        result["response_time"] = round((time.time() - start_time) * 1000, 2)  # in milliseconds
        result["status_code"] = response.status_code
        
        # If accessible, continue with more detailed analysis
        if response.status_code == 200:
            result["status"] = "Endpoint is accessible"
            result["content_length"] = len(response.content)
            result["server"] = response.headers.get("Server", "Unknown")
            
            # Check for SSL Certificate
            domain = urlparse(endpoint).hostname
            ssl_check = check_ssl_cert(domain)
            result["ssl_check"] = ssl_check
            
            # Check for security headers
            headers_check = check_security_headers(response.headers)
            result["security_headers"] = headers_check
            
            # Check open ports (only for non-IP addresses)
            if domain:
                result["open_ports"] = check_open_ports(domain)

            # Content inspection for SQLi and XSS
            vulnerabilities = content_inspection(response.text)
            result["vulnerabilities"] = vulnerabilities
            
        else:
            result["status"] = f"Non-200 status code: {response.status_code}"
    
    except requests.exceptions.RequestException as e:
        result["status"] = "Failed to connect"
        result["error"] = str(e)
    
    return result

# Multi-threaded scanning for multiple endpoints
def scan_multiple_endpoints(endpoints):
    threads = []
    results = []

    def thread_scan(endpoint):
        result = scan_vulnerabilities(endpoint)
        results.append(result)

    for endpoint in endpoints:
        thread = threading.Thread(target=thread_scan, args=(endpoint,))
        threads.append(thread)
        thread.start()

    for thread in threads:
        thread.join()
    
    return results

if __name__ == "__main__":
    # Example usage: scanning multiple endpoints concurrently
    urls = [
        "https://linea-mainnet.infura.io/v3/300b05a88e7a41a29e33ae295360faeb",
        "https://www.google.com",
        "https://www.example.com"
    ]
    
    scan_results = scan_multiple_endpoints(urls)
    print(json.dumps(scan_results, indent=4))
